<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Afficher les métadonnées EPUB</title>
</head>
<body>
  <input type="file" id="fileInput" webkitdirectory directory multiple  accept=".epub"/>
  <div id="metadata">
    <h2>Métadonnées</h2>
    <p id="title">Titre : </p>
    <p id="creator">Auteur : </p>
    <p id="language">langue : </p>


    <img id="cover" alt="Couverture" />
  </div>

  <script>
    document.getElementById('fileInput').addEventListener('change', handleFileSelect);
    async function getFileContent(filePath) {
  const response = await fetch(filePath);
  return response.blob();
}


function handleFileSelect(event) {
  const files = event.target.files;

  if (files.length > 0) {
    const file = findOpfFile(files);

    if (file) {
      const reader = new FileReader();

      reader.onload = async function (e) {
        const content = e.target.result;

        // Extraire les métadonnées
        const title = extractMetadata(content, 'title');
        const creator = extractMetadata(content, 'creator');
        const language = extractMetadata(content, 'language');

        // Afficher les métadonnées sur le site
        document.getElementById('title').textContent = `Titre : ${title}`;
        document.getElementById('creator').textContent = `Auteur : ${creator}`;
        document.getElementById('language').textContent = `Langue : ${language}`;

        // Extraire le chemin de la couverture à partir de la balise meta
        const coverPath = extractCoverPath(content);

        // Afficher la couverture s'il y a un chemin
        if (coverPath) {
          try {
            const coverImage = document.getElementById('coverImage');
            
            const coverContent = await getFileContent(coverPath);

            // Créer un objet Blob à partir du contenu de l'image
            const blob = new Blob([coverContent], { type: 'image/jpeg' });

            // Créer un Object URL à partir du Blob
            const url = URL.createObjectURL(blob);

            // Afficher l'image
            coverImage.src = url;
            coverImage.style.display = 'block';
          } catch (error) {
            console.error('Erreur lors du chargement de l\'image :', error);
          }
        }
      };

      reader.readAsText(file);
    } else {
      alert("Fichier OPF introuvable dans le dossier EPUB.");
    }
  }
}




    function findOpfFile(files) {
      for (const file of files) {
        if (file.name.toLowerCase().endsWith('.opf')) {
          return file;
        } else if (file.isDirectory) {
          const opfFile = findOpfFile(file.webkitGetAsEntry().createReader().readEntries());
          if (opfFile) {
            return opfFile;
          }
        }
      }
      return null;
    }

    function extractMetadata(content, key) {
      const regex = new RegExp(`<dc:${key}.*?>(.*?)<\/dc:${key}>`);
      const match = content.match(regex);

      if (match) {
        console.log(`Match trouvé pour ${key}:`, match[1]);
        return match[1];
      } else {
        console.log(`Aucun match trouvé pour ${key}`);
        return 'Non trouvé';
      }
    }

    function extractCoverPath(content) {
  const coverMetaRegex = /<meta\s+name="cover"\s+content="(.*?)"\s*\/?>/i;
  const coverMetaMatch = content.match(coverMetaRegex);

  if (coverMetaMatch && coverMetaMatch[1]) {
    const relativeCoverPath = coverMetaMatch[1];
    console.log(`Chemin relatif de la couverture trouvé :`, relativeCoverPath);
    return relativeCoverPath;
  } else {
    console.log(`Aucun chemin relatif de couverture trouvé`);
    return null;
  }
}

  </script>
</body>
</html>
